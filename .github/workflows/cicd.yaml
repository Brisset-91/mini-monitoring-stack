name: CI/CD Pipeline with DynamoDB

on:
  push:
    branches:
      - main
  pull_request:
    branches: [ main ]  

# Los trabajos que va a ejecutar
jobs:
  build-and-test:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: us-east-1
      AWS_ACCESS_KEY_ID: test
      AWS_SECRET_ACCESS_KEY: test
      DYNAMODB_ENDPOINT: http://localhost:4566
      TABLE_NAME: comentarios

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      # ===== SETUP DE LOCALSTACK =====
      - name: Start LocalStack
        run: |
          docker pull localstack/localstack:latest
          docker run -d \
            --name localstack \
            -p 4566:4566 \
            -e SERVICES=dynamodb \
            -e DEBUG=1 \
            -e DOCKER_HOST=unix:///var/run/docker.sock \
            -v /var/run/docker.sock:/var/run/docker.sock \
            localstack/localstack:latest
          
          echo "‚è≥ Waiting for LocalStack to be ready..."
          sleep 10

          # Verificar que LocalStack est√° corriendo
          curl -s http://localhost:4566/_localstack/health | jq '.'
          echo "‚úÖ LocalStack is running!"

      # ===== SETUP DE TERRAFORM =====
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Initialize and apply Terraform
        run: |
          cd terraform
          terraform init
          
          echo "üìã Terraform Plan:"
          terraform plan
          
          echo "üöÄ Creating DynamoDB table..."
          terraform apply -auto-approve
          
          echo "‚úÖ DynamoDB table created!"

      - name: Verify DynamoDB table
        run: |
          aws dynamodb list-tables \
            --endpoint-url http://localhost:4566 \
            --region us-east-1 \
            --no-cli-pager
          
          aws dynamodb describe-table \
            --table-name comentarios \
            --endpoint-url http://localhost:4566 \
            --region us-east-1 \
            --no-cli-pager
          
          echo "‚úÖ DynamoDB table verified!"

      # ===== TESTS B√ÅSICOS =====
      - name: Install backend dependencies
        run: |
          cd backend
          npm install

      - name: Run backend tests
        run: |
          cd backend
          npm test

      - name: Frontend build (static)
        run: echo "No build step needed for static frontend"


 # ===== DOCKER BUILD Y PUSH =====
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Set IMAGE_TAG
        run: echo "IMAGE_TAG=${GITHUB_SHA}" >> $GITHUB_ENV

      # Construir im√°genes localmente para testing antes de push
      - name: Build images for testing
        run: |
          docker build -t test-backend:latest ./backend
          docker build -t test-frontend:latest ./frontend
          echo "‚úÖ Test images built successfully"

    # ===== TESTING CON KUBERNETES =====
      - name: Start Minikube for testing
        uses: medyagh/setup-minikube@master
        with:
          minikube-version: 'latest'
          kubernetes-version: 'latest'

      - name: Verify Kubernetes cluster
        run: |
          kubectl cluster-info
          kubectl get nodes
          echo "‚úÖ Kubernetes cluster is ready!"

      - name: Load test images to Minikube
        run: |
          minikube image load test-backend:latest
          minikube image load test-frontend:latest
          echo "‚úÖ Test images loaded into Minikube" 


      # ===== DESPLEGAR LOCALSTACK EN KUBERNETES =====
      - name: Deploy LocalStack to Kubernetes
        run: |
          cat << EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: localstack-test
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: localstack-test
            template:
              metadata:
                labels:
                  app: localstack-test
              spec:
                containers:
                - name: localstack
                  image: localstack/localstack:latest
                  ports:
                  - containerPort: 4566
                  env:
                  - name: SERVICES
                    value: "dynamodb"
                  - name: DEBUG
                    value: "1"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: localstack-test
          spec:
            ports:
            - port: 4566
              targetPort: 4566
            selector:
              app: localstack-test
          EOF
          echo "‚úÖ LocalStack deployed to Kubernetes"

      - name: Wait for LocalStack in Kubernetes
        run: |
          echo "‚è≥ Waiting for LocalStack..."
          kubectl wait --for=condition=available --timeout=120s deployment/localstack-test
          
          # Esperar a que LocalStack est√© completamente inicializado
          sleep 15
          echo "‚úÖ LocalStack is ready in Kubernetes"

      - name: Create DynamoDB table in Kubernetes LocalStack
        run: |
          # Obtener el pod de LocalStack
          LOCALSTACK_POD=$(kubectl get pods -l app=localstack-test -o jsonpath='{.items[0].metadata.name}')
          
          echo "üì¶ Creating DynamoDB table in pod: $LOCALSTACK_POD"
          
          # Crear la tabla usando awslocal (o aws con endpoint)
          kubectl exec $LOCALSTACK_POD -- aws dynamodb create-table \
            --table-name comentarios \
            --attribute-definitions \
              AttributeName=id,AttributeType=S \
              AttributeName=fecha,AttributeType=N \
              AttributeName=tipo,AttributeType=S \
            --key-schema AttributeName=id,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --global-secondary-indexes \
              "IndexName=FechaIndex,KeySchema=[{AttributeName=tipo,KeyType=HASH},{AttributeName=fecha,KeyType=RANGE}],Projection={ProjectionType=ALL}" \
            --endpoint-url http://localhost:4566 \
            --region us-east-1 || echo "‚ö†Ô∏è Table might already exist"
          
          # Verificar que la tabla existe
          kubectl exec $LOCALSTACK_POD -- aws dynamodb list-tables \
            --endpoint-url http://localhost:4566 \
            --region us-east-1
          
          echo "‚úÖ DynamoDB table created in Kubernetes"
 

      # ===== PREPARAR MANIFIESTOS DE KUBERNETES =====
      - name: Prepare Kubernetes manifests for testing
        run: |
          # Hacer copias para testing
          cp k8s/backend-deployment.yaml k8s/backend-deployment-test.yaml
          cp k8s/frontend-deployment.yaml k8s/frontend-deployment-test.yaml
          
          # Actualizar im√°genes para usar las de testing
          sed -i 's|image: .*backend.*|image: test-backend:latest|g' k8s/backend-deployment-test.yaml
          sed -i 's|image: .*frontend.*|image: test-frontend:latest|g' k8s/frontend-deployment-test.yaml
          
          # Reemplazar variables de imagen si existen
          sed -i 's|\${IMAGE_TAG}|latest|g' k8s/frontend-deployment-test.yaml
          sed -i 's|\${IMAGE_TAG}|latest|g' k8s/backend-deployment-test.yaml
          
          echo "üìù Kubernetes manifests prepared for testing"

      - name: Create Kubernetes Secret for DynamoDB
        run: |
          kubectl create secret generic backend-secret \
            --from-literal=aws_region=us-east-1 \
            --from-literal=aws_access_key_id=test \
            --from-literal=aws_secret_access_key=test \
            --from-literal=dynamodb_endpoint=http://localstack-test:4566 \
            --from-literal=table_name=comentarios \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "üîê DynamoDB secrets created"

      - name: Deploy application to test environment
        run: |
          kubectl apply -f k8s/backend-deployment-test.yaml
          kubectl apply -f k8s/backend-service.yaml
          kubectl apply -f k8s/frontend-deployment-test.yaml
          kubectl apply -f k8s/frontend-service.yaml
          echo "üöÄ Application deployed to test environment"

      - name: Wait for test deployments
        run: |
          echo "‚è≥ Waiting for LocalStack..."
          kubectl wait --for=condition=available --timeout=180s deployment/localstack-test || echo "‚ö†Ô∏è LocalStack timeout"
          
          echo "‚è≥ Waiting for backend..."
          kubectl wait --for=condition=available --timeout=180s deployment/backend || echo "‚ö†Ô∏è Backend timeout"
          
          echo "‚è≥ Waiting for frontend..."
          kubectl wait --for=condition=available --timeout=180s deployment/frontend || echo "‚ö†Ô∏è Frontend timeout"

      - name: Run connectivity tests
        run: |
          echo "üß™ Running connectivity tests..."
          
          kubectl get pods -o wide
          
          echo "Testing backend connectivity..."
          kubectl run test-backend --image=curlimages/curl:latest --rm -i --restart=Never -- \
            curl -s --max-time 10 http://backend-service:3000/health || echo "‚ö†Ô∏è Backend test failed"
          
          echo "Testing frontend connectivity..."  
          kubectl run test-frontend --image=curlimages/curl:latest --rm -i --restart=Never -- \
            curl -s --max-time 10 http://frontend-service:80/ || echo "‚ö†Ô∏è Frontend test failed"
          
          echo "‚úÖ Connectivity tests completed"

      - name: Test DynamoDB operations
        run: |
          echo "üß™ Testing DynamoDB operations..."
          
          # Crear un comentario de prueba
          kubectl run test-dynamodb --image=curlimages/curl:latest --rm -i --restart=Never -- \
            curl -X POST http://backend-service:3000/comentarios \
            -H "Content-Type: application/json" \
            -d '{"autor":"Test CI/CD","mensaje":"Test from GitHub Actions"}' || echo "‚ö†Ô∏è POST test failed"
          
          sleep 2
          
          # Obtener comentarios
          kubectl run test-get --image=curlimages/curl:latest --rm -i --restart=Never -- \
            curl -s http://backend-service:3000/comentarios || echo "‚ö†Ô∏è GET test failed"
          
          echo "‚úÖ DynamoDB operations tested"

      - name: Show test results
        if: always()
        run: |
          echo "üìä Test Environment Status:"
          echo "=========================="
          
          echo "üì¶ Pods:"
          kubectl get pods -o wide
          
          echo ""
          echo "üåê Services:"
          kubectl get services
          
          echo ""
          echo "üìã Recent Events:"
          kubectl get events --sort-by='.lastTimestamp' | tail -15

      - name: Debug logs if tests failed
        if: failure()
        run: |
          echo "üêõ DEBUGGING INFORMATION"
          echo "======================="
          
          echo "üìÑ LocalStack logs:"
          kubectl logs -l app=localstack-test --tail=30 || echo "No LocalStack logs"
          
          echo ""
          echo "üìÑ Backend logs:"
          kubectl logs -l app=backend --tail=30 || echo "No backend logs"
          
          echo ""
          echo "üìÑ Frontend logs:"
          kubectl logs -l app=frontend --tail=30 || echo "No frontend logs"

      # ===== PUSH A DOCKER HUB (solo si los tests pasaron) =====
      - name: Push backend image to Docker Hub
        run: |
          docker tag test-backend:latest ${{ secrets.DOCKER_USERNAME }}/backend:latest
          docker tag test-backend:latest ${{ secrets.DOCKER_USERNAME }}/backend:${{ env.IMAGE_TAG }}
          docker push ${{ secrets.DOCKER_USERNAME }}/backend:latest
          docker push ${{ secrets.DOCKER_USERNAME }}/backend:${{ env.IMAGE_TAG }}
          echo "‚úÖ Backend images pushed to Docker Hub"

      - name: Push frontend image to Docker Hub
        run: |
          docker tag test-frontend:latest ${{ secrets.DOCKER_USERNAME }}/frontend:latest
          docker tag test-frontend:latest ${{ secrets.DOCKER_USERNAME }}/frontend:${{ env.IMAGE_TAG }}
          docker push ${{ secrets.DOCKER_USERNAME }}/frontend:latest
          docker push ${{ secrets.DOCKER_USERNAME }}/frontend:${{ env.IMAGE_TAG }}
          echo "‚úÖ Frontend images pushed to Docker Hub"

      # ===== PREPARAR MANIFESTS PARA DEPLOYMENT REAL =====
      - name: Replace image tags in frontend deployment files
        run: |
          # Actualizar frontend deployment
          sed -i "s|\${IMAGE_TAG}|${GITHUB_SHA}|g" k8s/frontend-deployment.yaml
          sed -i "s|:latest|:${GITHUB_SHA}|g" k8s/frontend-deployment.yaml
          
          # Actualizar backend deployment tambi√©n
          sed -i "s|\${IMAGE_TAG}|${GITHUB_SHA}|g" k8s/backend-deployment.yaml
          sed -i "s|:latest|:${GITHUB_SHA}|g" k8s/backend-deployment.yaml
          
          echo "üìù Image tags updated in all deployment files"
          echo "Frontend will use: ${{ secrets.DOCKER_USERNAME }}/frontend:${GITHUB_SHA}"
          echo "Backend will use: ${{ secrets.DOCKER_USERNAME }}/backend:${GITHUB_SHA}"

      # ===== INFORMACI√ìN PARA DEPLOYMENT MANUAL =====
      - name: Create deployment summary
        run: |
          echo "üéâ BUILD AND TEST COMPLETED SUCCESSFULLY!"
          echo "========================================"
          echo ""
          echo "üì¶ Images pushed to Docker Hub:"
          echo "  - ${{ secrets.DOCKER_USERNAME }}/backend:latest"
          echo "  - ${{ secrets.DOCKER_USERNAME }}/backend:${{ env.IMAGE_TAG }}"
          echo "  - ${{ secrets.DOCKER_USERNAME }}/frontend:latest"
          echo "  - ${{ secrets.DOCKER_USERNAME }}/frontend:${{ env.IMAGE_TAG }}"
          echo ""
          echo "üóÑÔ∏è Database: DynamoDB (LocalStack tested)"
          echo "üìä Table: comentarios with FechaIndex GSI"
          echo ""
          echo "‚úÖ Ready for deployment!"

      # Limpiar archivos temporales
      - name: Cleanup test files
        if: always()
        run: |
          rm -f k8s/*-test.yaml || true
          echo "üßπ Temporary files cleaned up"

  # ===== JOB SEPARADO PARA CREAR INSTRUCCIONES DE DEPLOYMENT =====
  create-deployment-guide:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.ref == 'refs/heads/main'  # Solo en main branch

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create deployment script for local
        run: |
          cat << 'EOF' > deploy-to-local.sh
          #!/bin/bash
          
          echo "üöÄ Deploying to local Docker Desktop Kubernetes with DynamoDB..."
          
          # Verificar kubectl
          if ! kubectl cluster-info > /dev/null 2>&1; then
              echo "‚ùå Error: Cannot connect to Kubernetes"
              echo "   Enable Kubernetes in Docker Desktop"
              exit 1
          fi
          
          CURRENT_CONTEXT=$(kubectl config current-context)
          echo "üìç Current context: $CURRENT_CONTEXT"
          
          # Desplegar LocalStack
          echo "üóÑÔ∏è Deploying LocalStack..."
          cat << LOCALSTACK | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: localstack
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: localstack
            template:
              metadata:
                labels:
                  app: localstack
              spec:
                containers:
                - name: localstack
                  image: localstack/localstack:latest
                  ports:
                  - containerPort: 4566
                  env:
                  - name: SERVICES
                    value: "dynamodb"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: localstack
          spec:
            ports:
            - port: 4566
              targetPort: 4566
            selector:
              app: localstack
          LOCALSTACK
          
          echo "‚è≥ Waiting for LocalStack..."
          kubectl wait --for=condition=available --timeout=120s deployment/localstack
          sleep 10
          
          # Crear tabla DynamoDB
          echo "üìä Creating DynamoDB table..."
          LOCALSTACK_POD=$(kubectl get pods -l app=localstack -o jsonpath='{.items[0].metadata.name}')
          kubectl exec $LOCALSTACK_POD -- aws dynamodb create-table \
            --table-name comentarios \
            --attribute-definitions \
              AttributeName=id,AttributeType=S \
              AttributeName=fecha,AttributeType=N \
              AttributeName=tipo,AttributeType=S \
            --key-schema AttributeName=id,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --global-secondary-indexes \
              "IndexName=FechaIndex,KeySchema=[{AttributeName=tipo,KeyType=HASH},{AttributeName=fecha,KeyType=RANGE}],Projection={ProjectionType=ALL}" \
            --endpoint-url http://localhost:4566 \
            --region us-east-1
          
          # Crear secrets
          echo "üîê Creating secrets..."
          kubectl create secret generic backend-secret \
            --from-literal=aws_region=us-east-1 \
            --from-literal=aws_access_key_id=test \
            --from-literal=aws_secret_access_key=test \
            --from-literal=dynamodb_endpoint=http://localstack:4566 \
            --from-literal=table_name=comentarios \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Aplicar manifests
          echo "üì¶ Deploying application..."
          kubectl apply -f k8s/backend-deployment.yaml
          kubectl apply -f k8s/backend-service.yaml
          kubectl apply -f k8s/frontend-deployment.yaml
          kubectl apply -f k8s/frontend-service.yaml
          
          echo "‚è≥ Waiting for deployments..."
          kubectl wait --for=condition=available --timeout=300s deployment/backend || true
          kubectl wait --for=condition=available --timeout=300s deployment/frontend || true
          
          echo "‚úÖ Deployment completed!"
          echo ""
          echo "üìä Status:"
          kubectl get pods -o wide
          kubectl get services
          
          EOF
          
          chmod +x deploy-to-local.sh

      - name: Create AWS deployment guide
        run: |
          cat << 'EOF' > deploy-to-aws.md
          # üöÄ Deployment Guide to AWS
          
          ## Prerequisites
          - AWS Account with DynamoDB access
          - AWS CLI configured
          - kubectl configured for EKS
          - Terraform installed
          
          ## Step 1: Deploy DynamoDB with Terraform
          
          ```bash
          cd terraform
          
          # Update provider to use real AWS (remove LocalStack endpoint)
          # Edit main.tf and remove the endpoints block
          
          terraform init
          terraform plan
          terraform apply
          ```
          
          ## Step 2: Create Kubernetes Secrets
          
          ```bash
          kubectl create secret generic backend-secret \
            --from-literal=aws_region=us-east-1 \
            --from-literal=aws_access_key_id=YOUR_ACCESS_KEY \
            --from-literal=aws_secret_access_key=YOUR_SECRET_KEY \
            --from-literal=table_name=comentarios
          
          # Note: For production, use IAM roles instead of access keys
          ```
          
          ## Step 3: Deploy Application
          
          ```bash
          kubectl apply -f k8s/backend-deployment.yaml
          kubectl apply -f k8s/backend-service.yaml
          kubectl apply -f k8s/frontend-deployment.yaml
          kubectl apply -f k8s/frontend-service.yaml
          ```
          
          ## Step 4: Verify Deployment
          
          ```bash
          kubectl get pods
          kubectl get services
          kubectl logs -l app=backend
          ```
          
          ## Production Recommendations
          
          1. **Use IAM Roles for Service Accounts (IRSA)**
          2. **Enable DynamoDB Point-in-Time Recovery**
          3. **Set up CloudWatch alarms**
          4. **Use Application Load Balancer**
          5. **Enable auto-scaling for DynamoDB**
          
          EOF

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-scripts
          path: |
            deploy-to-local.sh
            deploy-to-aws.md
    
    