name: CI/CD Pipeline with DynamoDB

on:
  push:
    branches:
      - main
  pull_request:
    branches: [ main ]  

# Los trabajos que va a ejecutar
jobs:
  build-and-test:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: us-east-1
      AWS_ACCESS_KEY_ID: test
      AWS_SECRET_ACCESS_KEY: test
      DYNAMODB_ENDPOINT: http://localhost:4566
      TABLE_NAME: comentarios

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      # ===== SETUP DE LOCALSTACK =====
      - name: Start LocalStack
        run: |
          docker pull localstack/localstack:latest
          docker run -d \
            --name localstack \
            -p 4566:4566 \
            -e SERVICES=dynamodb \
            -e DEBUG=1 \
            -e DOCKER_HOST=unix:///var/run/docker.sock \
            -v /var/run/docker.sock:/var/run/docker.sock \
            localstack/localstack:latest
          
          echo "‚è≥ Waiting for LocalStack to be ready..."
          sleep 10

          # Verificar que LocalStack est√° corriendo
          curl -s http://localhost:4566/_localstack/health | jq '.'
          echo "‚úÖ LocalStack is running!"

      # ===== SETUP DE TERRAFORM =====
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Initialize and apply Terraform
        run: |
          cd terraform-local-demo
          terraform init
          
          echo "üìã Terraform Plan:"
          terraform plan
          
          echo "üöÄ Creating DynamoDB table..."
          terraform apply -auto-approve
          
          echo "‚úÖ DynamoDB table created!"

      - name: Verify DynamoDB table
        run: |
          aws dynamodb list-tables \
            --endpoint-url http://localhost:4566 \
            --region us-east-1 \
            --no-cli-pager
          
          aws dynamodb describe-table \
            --table-name comentarios \
            --endpoint-url http://localhost:4566 \
            --region us-east-1 \
            --no-cli-pager
          
          echo "‚úÖ DynamoDB table verified!"

      # ===== TESTS B√ÅSICOS =====
      - name: Install backend dependencies
        run: |
          cd backend
          npm install

      - name: Run backend tests
        run: |
          cd backend
          npm test

      - name: Frontend build (static)
        run: echo "No build step needed for static frontend"


 # ===== DOCKER BUILD Y PUSH =====
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Set IMAGE_TAG
        run: echo "IMAGE_TAG=${GITHUB_SHA}" >> $GITHUB_ENV

      # Construir im√°genes localmente para testing antes de push
      - name: Build images for testing
        run: |
          docker build -t test-backend:latest ./backend
          docker build -t test-frontend:latest ./frontend
          echo "‚úÖ Test images built successfully"

# ===== TESTING CON KUBERNETES reemplazo(setup-minikube por kind)=====
      - name: Create Kind config file
        run: |
          cat << EOF > kind-config.yaml
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
          - role: control-plane
            extraPortMappings:
            - containerPort: 80
              hostPort: 80
            - containerPort: 3000
              hostPort: 3000
            - containerPort: 4566
              hostPort: 4566
          EOF
          echo "‚úÖ Kind config file created"

      - name: Create Kind cluster
        uses: helm/kind-action@v1.7.0
        with:
          cluster_name: test-cluster
          config: kind-config.yaml

      - name: Verify Kubernetes cluster
        run: |
          kubectl cluster-info
          kubectl get nodes
          sleep 5
          echo "‚úÖ Kubernetes cluster is ready!"

      - name: Load test images to Kind
        run: |
          kind load docker-image test-backend:latest --name test-cluster
          kind load docker-image test-frontend:latest --name test-cluster
          sleep 2
          echo "‚úÖ Test images loaded into Kind"

      # ===== DESPLEGAR LOCALSTACK EN KUBERNETES =====
      - name: Deploy LocalStack to Kubernetes
        run: |
          cat << EOF | kubectl apply -f -
          apiVersion: v1
          kind: Namespace
          metadata:
            name: localstack
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: localstack-test
            namespace: localstack
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: localstack-test
            template:
              metadata:
                labels:
                  app: localstack-test
              spec:
                containers:
                - name: localstack
                  image: localstack/localstack:latest
                  ports:
                  - containerPort: 4566
                  env:
                  - name: SERVICES
                    value: "dynamodb"
                  - name: DEBUG
                    value: "0"
                  - name: DOCKER_HOST
                    value: "unix:///var/run/docker.sock"
                  resources:
                    requests:
                      memory: "512Mi"
                      cpu: "500m"
                    limits:
                      memory: "1Gi"
                      cpu: "1000m"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: localstack-test
            namespace: localstack
          spec:
            type: ClusterIP
            ports:
            - port: 4566
              targetPort: 4566
              protocol: TCP
            selector:
              app: localstack-test
          EOF
          echo "‚úÖ LocalStack deployed to Kubernetes"

      - name: Wait for LocalStack in Kubernetes
        run: |
          echo "‚è≥ Waiting for LocalStack to be ready..."
          kubectl wait --for=condition=ready pod -l app=localstack-test -n localstack --timeout=120s || true
          
          # Esperar a que LocalStack est√© completamente inicializado
          sleep 10
          
          # Verificar que est√° respondiendo
          LOCALSTACK_POD=$(kubectl get pods -n localstack -l app=localstack-test -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
          if [ -z "$LOCALSTACK_POD" ]; then
            echo "‚ö†Ô∏è LocalStack pod not ready yet"
            kubectl get pods -n localstack
            exit 1
          fi
          echo "‚úÖ LocalStack pod is ready: $LOCALSTACK_POD"

      - name: Create DynamoDB table in Kubernetes LocalStack
        run: |
          # Obtener el pod de LocalStack
          LOCALSTACK_POD=$(kubectl get pods -n localstack -l app=localstack-test -o jsonpath='{.items[0].metadata.name}')
          
          echo "üì¶ Creating DynamoDB table in pod: $LOCALSTACK_POD"
          
          # Crear la tabla usando aws cli
          kubectl exec -n localstack $LOCALSTACK_POD -- aws dynamodb create-table \
            --table-name comentarios \
            --attribute-definitions \
              AttributeName=id,AttributeType=S \
              AttributeName=fecha,AttributeType=N \
              AttributeName=tipo,AttributeType=S \
            --key-schema AttributeName=id,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --global-secondary-indexes \
              "IndexName=FechaIndex,KeySchema=[{AttributeName=tipo,KeyType=HASH},{AttributeName=fecha,KeyType=RANGE}],Projection={ProjectionType=ALL}" \
            --endpoint-url http://localhost:4566 \
            --region us-east-1 2>&1 || echo "‚ö†Ô∏è Table might already exist or LocalStack not ready"
          
          sleep 5
          
          # Verificar que la tabla existe
          kubectl exec -n localstack $LOCALSTACK_POD -- aws dynamodb list-tables \
            --endpoint-url http://localhost:4566 \
            --region us-east-1
          
          echo "‚úÖ DynamoDB table created in Kubernetes"

      # ===== PREPARAR MANIFIESTOS DE KUBERNETES =====
      - name: Prepare Kubernetes manifests for testing
        run: |
          # Hacer copias para testing
          cp k8s/backend-deployment.yaml k8s/backend-deployment-test.yaml
          cp k8s/frontend-deployment.yaml k8s/frontend-deployment-test.yaml
          
          # Actualizar im√°genes para usar las de testing
          sed -i 's|image: .*backend.*|image: test-backend:latest|g' k8s/backend-deployment-test.yaml
          sed -i 's|image: .*frontend.*|image: test-frontend:latest|g' k8s/frontend-deployment-test.yaml
          
          # Reemplazar variables de imagen si existen
          sed -i 's|\${IMAGE_TAG}|latest|g' k8s/frontend-deployment-test.yaml
          sed -i 's|\${IMAGE_TAG}|latest|g' k8s/backend-deployment-test.yaml
          
          echo "üìù Kubernetes manifests prepared for testing"

      - name: Create Kubernetes Secret for DynamoDB
        run: |
          kubectl create namespace app || true
          kubectl create secret generic backend-secret \
            --from-literal=aws_region=us-east-1 \
            --from-literal=aws_access_key_id=test \
            --from-literal=aws_secret_access_key=test \
            --from-literal=dynamodb_endpoint=http://localstack-test.localstack:4566 \
            --from-literal=table_name=comentarios \
            --namespace=app \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "üîê DynamoDB secrets created"

      - name: Deploy application to test environment
        run: |
          # Inyectar namespace en los manifests
          sed -i 's/namespace: .*/namespace: app/g' k8s/backend-deployment-test.yaml k8s/frontend-deployment-test.yaml
          
          kubectl apply -f k8s/backend-deployment-test.yaml -n app
          kubectl apply -f k8s/backend-service.yaml -n app
          kubectl apply -f k8s/frontend-deployment-test.yaml -n app
          kubectl apply -f k8s/frontend-service.yaml -n app
          echo "üöÄ Application deployed to test environment"

      - name: Wait for test deployments
        run: |
          echo "‚è≥ Waiting for backend..."
          kubectl wait --for=condition=available --timeout=180s deployment/backend -n app || echo "‚ö†Ô∏è Backend timeout"
          
          echo "‚è≥ Waiting for frontend..."
          kubectl wait --for=condition=available --timeout=180s deployment/frontend -n app || echo "‚ö†Ô∏è Frontend timeout"
          
          sleep 10
          echo "‚úÖ Deployments ready"

      - name: Show test results
        if: always()
        run: |
          echo "üìä Test Environment Status:"
          echo "=========================="
          
          echo "üì¶ Pods (app namespace):"
          kubectl get pods -n app -o wide || true
          
          echo ""
          echo "üì¶ Pods (localstack namespace):"
          kubectl get pods -n localstack -o wide || true
          
          echo ""
          echo "üåê Services (app):"
          kubectl get services -n app || true
          
          echo ""
          echo "üìã Recent Events:"
          kubectl get events -n app --sort-by='.lastTimestamp' 2>/dev/null | tail -10 || true

      - name: Debug logs if tests failed
        if: failure()
        run: |
          echo "üêõ DEBUGGING INFORMATION"
          echo "======================="
          
          echo "üìÑ LocalStack logs:"
          kubectl logs -n localstack -l app=localstack-test --tail=50 || echo "No LocalStack logs"
          
          echo ""
          echo "üìÑ Backend logs:"
          kubectl logs -n app -l app=backend --tail=50 || echo "No backend logs"
          
          echo ""
          echo "üìÑ Frontend logs:"
          kubectl logs -n app -l app=frontend --tail=50 || echo "No frontend logs"

      # ===== PUSH A DOCKER HUB (solo si los tests pasaron) =====
      - name: Push backend image to Docker Hub
        run: |
          docker tag test-backend:latest ${{ secrets.DOCKER_USERNAME }}/backend:latest
          docker tag test-backend:latest ${{ secrets.DOCKER_USERNAME }}/backend:${{ env.IMAGE_TAG }}
          docker push ${{ secrets.DOCKER_USERNAME }}/backend:latest
          docker push ${{ secrets.DOCKER_USERNAME }}/backend:${{ env.IMAGE_TAG }}
          echo "‚úÖ Backend images pushed to Docker Hub"

      - name: Push frontend image to Docker Hub
        run: |
          docker tag test-frontend:latest ${{ secrets.DOCKER_USERNAME }}/frontend:latest
          docker tag test-frontend:latest ${{ secrets.DOCKER_USERNAME }}/frontend:${{ env.IMAGE_TAG }}
          docker push ${{ secrets.DOCKER_USERNAME }}/frontend:latest
          docker push ${{ secrets.DOCKER_USERNAME }}/frontend:${{ env.IMAGE_TAG }}
          echo "‚úÖ Frontend images pushed to Docker Hub"

      # ===== PREPARAR MANIFESTS PARA DEPLOYMENT REAL =====
      - name: Replace image tags in frontend deployment files
        run: |
          # Actualizar frontend deployment
          sed -i "s|\${IMAGE_TAG}|${GITHUB_SHA}|g" k8s/frontend-deployment.yaml
          sed -i "s|:latest|:${GITHUB_SHA}|g" k8s/frontend-deployment.yaml
          
          # Actualizar backend deployment tambi√©n
          sed -i "s|\${IMAGE_TAG}|${GITHUB_SHA}|g" k8s/backend-deployment.yaml
          sed -i "s|:latest|:${GITHUB_SHA}|g" k8s/backend-deployment.yaml
          
          echo "üìù Image tags updated in all deployment files"
          echo "Frontend will use: ${{ secrets.DOCKER_USERNAME }}/frontend:${GITHUB_SHA}"
          echo "Backend will use: ${{ secrets.DOCKER_USERNAME }}/backend:${GITHUB_SHA}"

      # ===== INFORMACI√ìN PARA DEPLOYMENT MANUAL =====
      - name: Create deployment summary
        run: |
          echo "üéâ BUILD AND TEST COMPLETED SUCCESSFULLY!"
          echo "========================================"
          echo ""
          echo "üì¶ Images pushed to Docker Hub:"
          echo "  - ${{ secrets.DOCKER_USERNAME }}/backend:latest"
          echo "  - ${{ secrets.DOCKER_USERNAME }}/backend:${{ env.IMAGE_TAG }}"
          echo "  - ${{ secrets.DOCKER_USERNAME }}/frontend:latest"
          echo "  - ${{ secrets.DOCKER_USERNAME }}/frontend:${{ env.IMAGE_TAG }}"
          echo ""
          echo "üóÑÔ∏è Database: DynamoDB (LocalStack tested)"
          echo "üìä Table: comentarios with FechaIndex GSI"
          echo ""
          echo "‚úÖ Ready for deployment!"

      # Limpiar archivos temporales
      - name: Cleanup test files
        if: always()
        run: |
          rm -f k8s/*-test.yaml || true
          echo "üßπ Temporary files cleaned up"

  # ===== JOB SEPARADO PARA CREAR INSTRUCCIONES DE DEPLOYMENT =====
  create-deployment-guide:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.ref == 'refs/heads/main'  # Solo en main branch

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create deployment script for local
        run: |
          cat << 'EOF' > deploy-to-local.sh
          #!/bin/bash
          
          echo "üöÄ Deploying to local Docker Desktop Kubernetes with DynamoDB..."
          
          # Verificar kubectl
          if ! kubectl cluster-info > /dev/null 2>&1; then
              echo "‚ùå Error: Cannot connect to Kubernetes"
              echo "   Enable Kubernetes in Docker Desktop"
              exit 1
          fi
          
          CURRENT_CONTEXT=$(kubectl config current-context)
          echo "üìç Current context: $CURRENT_CONTEXT"
          
          # Desplegar LocalStack
          echo "üóÑÔ∏è Deploying LocalStack..."
          cat << LOCALSTACK | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: localstack
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: localstack
            template:
              metadata:
                labels:
                  app: localstack
              spec:
                containers:
                - name: localstack
                  image: localstack/localstack:latest
                  ports:
                  - containerPort: 4566
                  env:
                  - name: SERVICES
                    value: "dynamodb"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: localstack
          spec:
            ports:
            - port: 4566
              targetPort: 4566
            selector:
              app: localstack
          LOCALSTACK
          
          echo "‚è≥ Waiting for LocalStack..."
          kubectl wait --for=condition=available --timeout=120s deployment/localstack
          sleep 10
          
          # Crear tabla DynamoDB
          echo "üìä Creating DynamoDB table..."
          LOCALSTACK_POD=$(kubectl get pods -l app=localstack -o jsonpath='{.items[0].metadata.name}')
          kubectl exec $LOCALSTACK_POD -- aws dynamodb create-table \
            --table-name comentarios \
            --attribute-definitions \
              AttributeName=id,AttributeType=S \
              AttributeName=fecha,AttributeType=N \
              AttributeName=tipo,AttributeType=S \
            --key-schema AttributeName=id,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --global-secondary-indexes \
              "IndexName=FechaIndex,KeySchema=[{AttributeName=tipo,KeyType=HASH},{AttributeName=fecha,KeyType=RANGE}],Projection={ProjectionType=ALL}" \
            --endpoint-url http://localhost:4566 \
            --region us-east-1
          
          # Crear secrets
          echo "üîê Creating secrets..."
          kubectl create secret generic backend-secret \
            --from-literal=aws_region=us-east-1 \
            --from-literal=aws_access_key_id=test \
            --from-literal=aws_secret_access_key=test \
            --from-literal=dynamodb_endpoint=http://localstack:4566 \
            --from-literal=table_name=comentarios \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Aplicar manifests
          echo "üì¶ Deploying application..."
          kubectl apply -f k8s/backend-deployment.yaml
          kubectl apply -f k8s/backend-service.yaml
          kubectl apply -f k8s/frontend-deployment.yaml
          kubectl apply -f k8s/frontend-service.yaml
          
          echo "‚è≥ Waiting for deployments..."
          kubectl wait --for=condition=available --timeout=300s deployment/backend || true
          kubectl wait --for=condition=available --timeout=300s deployment/frontend || true
          
          echo "‚úÖ Deployment completed!"
          echo ""
          echo "üìä Status:"
          kubectl get pods -o wide
          kubectl get services
          
          EOF
          
          chmod +x deploy-to-local.sh

      - name: Create AWS deployment guide
        run: |
          cat << 'EOF' > deploy-to-aws.md
          # üöÄ Deployment Guide to AWS
          
          ## Prerequisites
          - AWS Account with DynamoDB access
          - AWS CLI configured
          - kubectl configured for EKS
          - Terraform installed
          
          ## Step 1: Deploy DynamoDB with Terraform
          
          ```bash
          cd terraform-local-demo
          
          # Update provider to use real AWS (remove LocalStack endpoint)
          # Edit main.tf and remove the endpoints block
          
          terraform init
          terraform plan
          terraform apply
          ```
          
          ## Step 2: Create Kubernetes Secrets
          
          ```bash
          kubectl create secret generic backend-secret \
            --from-literal=aws_region=us-east-1 \
            --from-literal=aws_access_key_id=YOUR_ACCESS_KEY \
            --from-literal=aws_secret_access_key=YOUR_SECRET_KEY \
            --from-literal=table_name=comentarios
          
          # Note: For production, use IAM roles instead of access keys
          ```
          
          ## Step 3: Deploy Application
          
          ```bash
          kubectl apply -f k8s/backend-deployment.yaml
          kubectl apply -f k8s/backend-service.yaml
          kubectl apply -f k8s/frontend-deployment.yaml
          kubectl apply -f k8s/frontend-service.yaml
          ```
          
          ## Step 4: Verify Deployment
          
          ```bash
          kubectl get pods
          kubectl get services
          kubectl logs -l app=backend
          ```
          
          ## Production Recommendations
          
          1. **Use IAM Roles for Service Accounts (IRSA)**
          2. **Enable DynamoDB Point-in-Time Recovery**
          3. **Set up CloudWatch alarms**
          4. **Use Application Load Balancer**
          5. **Enable auto-scaling for DynamoDB**
          
          EOF

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-scripts
          path: |
            deploy-to-local.sh
            deploy-to-aws.md
    
    